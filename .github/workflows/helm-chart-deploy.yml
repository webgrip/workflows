name: Helm Deploy with Detailed Job Summary

on:
  workflow_call:
    secrets:
      DOCKER_USERNAME:
        description: 'Docker Username'
        required: true
      DOCKER_TOKEN:
        description: 'Docker Token'
        required: true
      DIGITAL_OCEAN_API_KEY:
        description: 'DigitalOcean API Key'
        required: true
      SOPS_AGE_KEY:
        description: 'SOPS Age private key'
        required: false
    inputs:
      environment:
        description: 'Environment to deploy to'
        type: string
        required: true
        default: 'staging'
      path:
        description: 'Path to the Helm chart you wish to deploy'
        type: string
        required: true
      tag:
        description: 'Tag to deploy'
        type: string
        required: false
      image_tag_key:
        description: 'Helm --set key path for the image tag (e.g., image.tag or controllers.api.image.tag). If empty, tag is not injected.'
        type: string
        required: false
        default: ''

permissions:
  contents: read
  packages: read

concurrency:
  group: deploy-${{ inputs.environment }}-${{ inputs.path }}
  cancel-in-progress: false

jobs:
  deploy-helm:
    name: ${{ inputs.path }}
    runs-on: arc-runner-set
    timeout-minutes: 30
    container:
      image: webgrip/helm-deploy:latest
      credentials:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
    env:
      DO_CLUSTER_NAME: webgrip-${{ inputs.environment }}-cluster
      DO_KUBECONFIG_FILE: './doks-kubeconfig'
      SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY || '' }}

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Validate inputs (non-fatal warnings)
        run: |
          set -euo pipefail
          if [ -n "${{ inputs.tag }}" ] && [ -z "${{ inputs.image_tag_key }}" ]; then
            echo "::warning::'tag' provided but 'image_tag_key' is empty. The tag will NOT be injected into the chart." >&2
          fi
          if [ -z "${{ inputs.tag }}" ] && [ -n "${{ inputs.image_tag_key }}" ]; then
            echo "::notice::'image_tag_key' provided but no 'tag' value. No --set injection will occur." >&2
          fi

      - name: Init deployment stats placeholder
        run: |
          set -euo pipefail
          # Ensure placeholder files exist so later collection never fails
          echo 'Chart,Namespace,Time,Status,Error' > deployment-stats.csv
          echo 'No deployment attempted yet.' > overall-stats.txt

      - name: Authenticate doctl
        env:
          DIGITAL_OCEAN_API_KEY: ${{ secrets.DIGITAL_OCEAN_API_KEY }}
        run: |
          set -euo pipefail
          echo "::add-mask::${DIGITAL_OCEAN_API_KEY}"
          doctl auth init --access-token "${DIGITAL_OCEAN_API_KEY}"

      - name: Helm registry login (for OCI deps like ghcr.io)
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        run: |
          set -euo pipefail
          echo "::add-mask::${DOCKER_TOKEN}"
          helm version
          echo "${DOCKER_TOKEN}" | helm registry login ghcr.io --username "${DOCKER_USERNAME}" --password-stdin || true

      - name: Fetch DOKS kubeconfig
        run: |
          set -euo pipefail
          KUBECONFIG="$DO_KUBECONFIG_FILE" doctl kubernetes cluster kubeconfig save "$DO_CLUSTER_NAME"
          chmod 600 "$DO_KUBECONFIG_FILE" || true
          echo "KUBECONFIG=$DO_KUBECONFIG_FILE" >> "$GITHUB_ENV"

      - name: Cluster preflight (non-fatal)
        continue-on-error: true
        run: |
          set +e
          echo "Cluster preflight (redacted): checking reachability only..."
          if kubectl get namespace kube-system >/dev/null 2>&1; then
            echo "Cluster reachable ✅"
          else
            echo "::warning::Cluster not reachable (kube-system ns query failed)"
          fi
          # Intentionally not outputting version, nodes, IPs, or other sensitive details.

      - name: Mask SOPS key (if provided)
        if: ${{ env.SOPS_AGE_KEY != '' }}
        run: echo "::add-mask::${SOPS_AGE_KEY}"

      - name: Decrypt SOPS file (secure temp, auto-clean)
        if: ${{ env.SOPS_AGE_KEY != '' }}
        id: decrypt_sops
        env:
          RUNNER_TEMP: ${{ runner.temp }}
        run: |
          set -euo pipefail
          chartDir="${{ inputs.path }}"
          export SOPS_AGE_KEY=${{ secrets.SOPS_AGE_KEY }}
          if [ -f "$chartDir/values.sops.yaml" ]; then
            umask 077
            # Use a portable mktemp pattern (Xs must be at end for BusyBox compatibility), then append suffix
            : "${RUNNER_TEMP:=/tmp}"
            _tmp_file="$(mktemp "${RUNNER_TEMP}/values.dec.XXXXXX")"
            TMP_VALUES="${_tmp_file}.yaml"
            mv "$_tmp_file" "$TMP_VALUES"
            sops --decrypt "$chartDir/values.sops.yaml" > "$TMP_VALUES"
            echo "sops_used=true" >> "$GITHUB_OUTPUT"
            echo "VALUES_FILE=$TMP_VALUES" >> "$GITHUB_ENV"
            echo "TMP_VALUES=$TMP_VALUES" >> "$GITHUB_ENV"
          else
            echo "sops_used=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Helm lint & template (tolerant)
        id: lint
        continue-on-error: true
        run: |
          set -euo pipefail
          chartDir="${{ inputs.path }}"
          echo "Resolving Helm chart dependencies..."
          # Add missing HTTP(S) repos declared in dependencies
          if [ -f "$chartDir/Chart.yaml" ]; then
            repos=$(yq e -r '.dependencies[]?.repository' "$chartDir/Chart.yaml" 2>/dev/null | sort -u || true)
            for repoUrl in $repos; do
              case "$repoUrl" in
                http://*|https://*)
                  repoName=$(echo "$repoUrl" | sed 's#https\?://##; s#[^A-Za-z0-9]#-#g')
                  if ! helm repo list 2>/dev/null | awk 'NR>1 {print $1}' | grep -q "^${repoName}$"; then
                    echo "Adding helm repo $repoName -> $repoUrl"
                    helm repo add "$repoName" "$repoUrl" >/dev/null 2>&1 || true
                  fi
                  ;;
                oci://*) : ;; # OCI handled implicitly
              esac
            done
            helm repo update >/dev/null 2>&1 || true
          fi
          if [ -f "$chartDir/Chart.lock" ]; then
            echo "Chart.lock found. Running 'helm dependency build' for reproducible deps."
            if ! helm dependency build "$chartDir" 2>dep_err.log; then
              echo "helm dependency build failed; showing dep_err.log:" >&2
              cat dep_err.log >&2 || true
              echo "Falling back to 'helm dependency update' (may refresh versions)." >&2
              helm dependency update "$chartDir"
            fi
          else
            echo "No Chart.lock present. Running 'helm dependency update'."
            helm dependency update "$chartDir"
          fi
          echo "Dependency charts directory contents:" && ls -1 "$chartDir/charts" 2>/dev/null || echo "(charts/ directory empty or missing)"
          echo "Listing dependencies declared in Chart.yaml:" && yq e '.dependencies[] | .name + " " + (.version // "") + " " + (.repository // "")' "$chartDir/Chart.yaml" 2>/dev/null || echo "(no dependencies section)"
          lint_status=0
          if ! helm lint "$chartDir"; then
            lint_status=$?
            echo "::error::Helm lint failed (exit $lint_status). Skipping diff/deploy." >&2
          fi
          ns=$(yq e '.namespace' "$chartDir/values.yaml" 2>/dev/null || echo default)
          if [ $lint_status -eq 0 ]; then
            if [ -n "${VALUES_FILE:-}" ]; then
              helm template "$chartDir" --namespace "$ns" -f "$VALUES_FILE" >/dev/null || true
            elif [ -f "$chartDir/values.yaml" ]; then
              helm template "$chartDir" --namespace "$ns" -f "$chartDir/values.yaml" >/dev/null || true
            else
              helm template "$chartDir" --namespace "$ns" >/dev/null || true
            fi
          fi
          echo "namespace=$ns" >> "$GITHUB_OUTPUT"
          echo "lint_exit_code=$lint_status" >> "$GITHUB_OUTPUT"

      - name: Record lint failure in stats
        if: steps.lint.outputs.lint_exit_code != '0'
        run: |
          set -euo pipefail
          chartDir="${{ inputs.path }}"
          chartName=$(basename "$chartDir")
          namespace="${{ steps.lint.outputs.namespace || 'default' }}"
          if ! grep -q ",$chartName," deployment-stats.csv 2>/dev/null; then
            echo "$chartName,$namespace,00:00:00,Skipped (lint failed),lint failed" >> deployment-stats.csv
            echo "Overall, deployment skipped due to lint failure." > overall-stats.txt
          fi

      - name: Helm diff (captured, non-blocking)
        id: diff
        if: steps.lint.outputs.lint_exit_code == '0'
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          chartDir="${{ inputs.path }}"
          release=$(basename "$chartDir")
          ns="${{ steps.lint.outputs.namespace || 'default' }}"
          args=()
          [ -n "${VALUES_FILE:-}" ] && args+=(-f "$VALUES_FILE")
          [ -z "${VALUES_FILE:-}" ] && [ -f "$chartDir/values.yaml" ] && args+=(-f "$chartDir/values.yaml")
          if [ -n "${{ inputs.tag }}" ] && [ -n "${{ inputs.image_tag_key }}" ]; then
            args+=(--set "${{ inputs.image_tag_key }}=${{ inputs.tag }}")
          fi
          helm plugin list | grep -q 'diff' || helm plugin install https://github.com/databus23/helm-diff
          helm diff upgrade "$release" "$chartDir" --namespace "$ns" --allow-unreleased --suppress-secrets --no-color "${args[@]}" > helm-diff.txt 2>&1 || true
          {
            echo "diff<<DIFF_EOF"
            sed -e 's/[[:cntrl:]]//g' helm-diff.txt || true
            echo "DIFF_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Deploy the specified Helm chart
        id: deploy
        if: steps.lint.outputs.lint_exit_code == '0'
        continue-on-error: true
        env:
          NS: ${{ steps.lint.outputs.namespace }}
        shell: bash
        run: |
          set +e

          echo "Chart,Namespace,Time,Status,Error" > deployment-stats.csv
          chartDir="${{ inputs.path }}"
          chartName=$(basename "$chartDir")
          namespace="${NS:-default}"

          if [ -n "${VALUES_FILE:-}" ]; then
            valuesFile="$VALUES_FILE"
          elif [ -f "$chartDir/values.yaml" ]; then
            valuesFile="$chartDir/values.yaml"
          else
            valuesFile=""
          fi

          echo "Deploying chart '$chartName' to namespace '$namespace'..."
          start=$(date +%s)

          helmCmd="helm upgrade --install \"$chartName\" \"$chartDir\" \
            --namespace \"$namespace\" \
            --create-namespace \
            --wait --timeout 10m \
            --history-max 10 \
            --atomic --cleanup-on-fail"

          if [ -n "$valuesFile" ]; then
            helmCmd="$helmCmd --values \"$valuesFile\""
          fi

          # Optional dynamic image tag injection
          if [ -n "${{ inputs.tag }}" ] && [ -n "${{ inputs.image_tag_key }}" ]; then
            helmCmd="$helmCmd --set ${{ inputs.image_tag_key }}='${{ inputs.tag }}'"
          fi

          helmOutput=$(eval "$helmCmd" 2>&1)
          helmExitCode=$?

          if [ $helmExitCode -eq 0 ]; then
            status="Success ✅"
            error=""
            exit_code=0
          else
            status="Failed ❌"
            error="Deployment failed"
            exit_code=1
          fi

          end=$(date +%s)
          duration=$((end - start))
          duration_formatted=$(printf "%02d:%02d:%02d" $((duration/3600)) $(((duration%3600)/60)) $((duration%60)))

          echo "$chartName,$namespace,$duration_formatted,$status,$error" >> deployment-stats.csv
          echo "exit_code=$exit_code" >> $GITHUB_OUTPUT

          {
            echo "helm_output<<HELM_OUT_EOF"
            printf "%s\n" "$helmOutput"
            echo "HELM_OUT_EOF"
          } >> "$GITHUB_OUTPUT"

          if [ $exit_code -eq 0 ]; then
            echo "Overall, 1 chart deployed in $duration_formatted ⏱️" > overall-stats.txt
          else
            echo "Overall, 1 chart deployment failed after $duration_formatted ⏱️" > overall-stats.txt
          fi

      - name: Collect Deployment Stats
        id: collect-stats
        if: always()
        run: |
          set -euo pipefail
          if [ -f deployment-stats.csv ]; then
            stats=$(cat deployment-stats.csv)
          else
            stats='Chart,Namespace,Time,Status,Error'
          fi
          if [ -f overall-stats.txt ]; then
            overall=$(cat overall-stats.txt)
          else
            overall='No overall deployment stats available.'
          fi
          {
            echo "stats<<STATS_EOF"
            printf '%s\n' "$stats"
            echo "STATS_EOF"
            echo "overall<<OVERALL_EOF"
            printf '%s\n' "$overall"
            echo "OVERALL_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Render Helm templates for summary
        if: always()
        shell: bash -eo pipefail {0}
        run: |
          set -Eeuo pipefail
          chartDir="${{ inputs.path }}"
          chartName=$(basename "$chartDir")
          rendered="rendered-manifests.yaml"
          ns="${{ steps.lint.outputs.namespace || 'default' }}"

          valuesFile=""
          if [ -n "${VALUES_FILE:-}" ]; then
            valuesFile="$VALUES_FILE"
          elif [ -f "$chartDir/values.yaml" ]; then
            valuesFile="$chartDir/values.yaml"
          fi

          helmCmd=(helm template "$chartName" "$chartDir" --namespace "$ns")
          [ -n "$valuesFile" ] && helmCmd+=(--values "$valuesFile")
          if [ -n "${{ inputs.tag }}" ] && [ -n "${{ inputs.image_tag_key }}" ]; then
            helmCmd+=(--set "${{ inputs.image_tag_key }}=${{ inputs.tag }}")
          fi

          echo "Rendering helm templates to $rendered"
          "${helmCmd[@]}" > "$rendered" 2>&1 || true

          if [ -d "$chartDir/templates" ]; then
            find "$chartDir/templates" -maxdepth 1 -type f -print > template-files.txt || true
          else
            : > template-files.txt
          fi

          cp -f "$chartDir/Chart.yaml" chart-Chart.yaml 2>/dev/null || true
          if [ "${{ steps.decrypt_sops.outputs.sops_used }}" = "true" ]; then
            [ -n "$valuesFile" ] && cp -f "$valuesFile" chart-values.yaml 2>/dev/null || true
          fi

      - name: Generate Job Summary with Deployment Stats
        if: always()
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_STATS: ${{ steps.collect-stats.outputs.stats }}
          OVERALL_STATS: ${{ steps.collect-stats.outputs.overall }}
          HELM_OUTPUT: ${{ steps.deploy.outputs.helm_output }}
          HELM_DIFF: ${{ steps.diff.outputs.diff }}
          SOPS_USED: ${{ steps.decrypt_sops.outputs.sops_used }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const statsCSV = process.env.DEPLOYMENT_STATS || '';
            const overallStats = process.env.OVERALL_STATS || '';
            const helmOutput = process.env.HELM_OUTPUT || '';
            const helmDiff = process.env.HELM_DIFF || '';
            const renderedPath = path.join(process.cwd(), 'rendered-manifests.yaml');
            const templateListPath = path.join(process.cwd(), 'template-files.txt');
            const chartYamlPath = path.join(process.cwd(), 'chart-Chart.yaml');
            const chartValuesPath = path.join(process.cwd(), 'chart-values.yaml');
            const sopsUsed = (process.env.SOPS_USED || '').toLowerCase() === 'true';

            core.summary
              .addHeading('Deployment Overview', 2)
              .addRaw(overallStats).addEOL().addSeparator();

            if (statsCSV) {
              const lines = statsCSV.trim().split('\n');
              const header = lines.shift().split(',');
              const dataRows = lines.map(l => l.split(','));
              core.summary.addHeading('Per-Chart Deployment Details', 3).addTable([header, ...dataRows]);
            } else {
              core.summary.addRaw('No deployment statistics available.').addEOL();
            }

            if (helmDiff) {
              core.summary.addHeading('Helm Diff (proposed vs current)', 3).addCodeBlock(helmDiff, 'diff');
            }

            if (helmOutput) {
              core.summary.addHeading('Helm Command Output', 3).addCodeBlock(helmOutput, 'bash');
            }

            if (fs.existsSync(chartYamlPath)) {
              core.summary.addHeading('Chart.yaml', 3).addCodeBlock(fs.readFileSync(chartYamlPath, 'utf8'), 'yaml');
            }

            if (fs.existsSync(chartValuesPath)) {
              if (sopsUsed) {
                core.summary.addHeading('Values used for render', 3).addRaw('Suppressed (SOPS secrets in use)').addEOL();
              } else {
                core.summary.addHeading('Values used for render', 3).addCodeBlock(fs.readFileSync(chartValuesPath, 'utf8'), 'yaml');
              }
            }

            if (fs.existsSync(templateListPath)) {
              const files = fs.readFileSync(templateListPath, 'utf8').trim().split('\n').filter(Boolean);
              if (files.length) {
                core.summary.addHeading('Chart template files', 3);
                for (const f of files) {
                  try {
                    const name = path.basename(f);
                    core.summary.addHeading(name, 4).addCodeBlock(fs.readFileSync(f, 'utf8'), 'yaml');
                  } catch {}
                }
              }
            }

            if (fs.existsSync(renderedPath)) {
              const rendered = fs.readFileSync(renderedPath, 'utf8');
              const containsSecret = /\bkind:\s+Secret\b/i.test(rendered);
              if (sopsUsed || containsSecret) {
                core.summary.addHeading('Rendered Kubernetes Manifests', 3)
                           .addRaw('Suppressed due to presence of secrets (SOPS or Secret kind detected).');
              } else {
                core.summary.addHeading('Rendered Kubernetes Manifests', 3).addCodeBlock(rendered, 'yaml');
              }
            }

            await core.summary.write();

      - name: Upload artifacts (no secrets)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: helm-artifacts-${{ github.run_attempt }}
          if-no-files-found: ignore
          path: |
            rendered-manifests.yaml
            template-files.txt
            chart-Chart.yaml
            helm-diff.txt
          retention-days: 1

      - name: Secure cleanup (remove decrypted temp)
        if: always()
        run: |
          set -euo pipefail
          [ -n "${TMP_VALUES:-}" ] && (shred -u "$TMP_VALUES" 2>/dev/null || rm -f "$TMP_VALUES") || true

      - name: Fail if Helm Failed
        if: steps.deploy.outputs.exit_code == '1'
        run: |
          echo "Deployment was not successful. Marking job as failed."
          exit 1
