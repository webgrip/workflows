name: "[Call] Create repository from template"

on:
  workflow_call:
    inputs:
      template_owner:
        description: "Owner of the template repository"
        type: string
        required: true
      template_repo:
        description: "Name of the template repository"
        type: string
        required: true
      new_repo_name:
        description: "Name of the new repository to be created"
        type: string
        required: true
      visibility:
        description: "Visibility of the new repository"
        type: string
        required: true
        default: "private"
      topics:
        description: "Comma-separated list of topics to apply to the new repository"
        type: string
        required: false
        default: ""
    secrets:
      WEBGRIP_CI_CLIENT_ID:
        description: "GitHub App ID (numeric)"
        required: true
      WEBGRIP_CI_APP_PRIVATE_KEY:
        description: "GitHub App private key (PEM)"
        required: true

permissions:
  contents: write
  pull-requests: write
  actions: write
  pages: write

jobs:
  create-repo-from-template:
    name: "Create repository"
    runs-on: arc-runner-set

    env:
      ORG: ${{ github.repository_owner }}
      NEW_REPO: ${{ inputs.new_repo_name }}
      VISIBILITY: ${{ inputs.visibility }}
      TOPICS: ${{ inputs.topics }}
      TEMPLATE_OWNER: ${{ inputs.template_owner }}
      TEMPLATE_REPO: ${{ inputs.template_repo }}

    steps:
      - name: Mint GitHub App installation token (owner-based)
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.WEBGRIP_CI_CLIENT_ID }}
          private-key: ${{ secrets.WEBGRIP_CI_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG }}

      - name: Create repo from template + topics + merge options
        id: gen
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org = process.env.ORG;
            const name = process.env.NEW_REPO;
            const isPrivate = (process.env.VISIBILITY !== 'public');

            const { data: repo } = await github.request('POST /repos/{template_owner}/{template_repo}/generate', {
              template_owner: process.env.TEMPLATE_OWNER,
              template_repo: process.env.TEMPLATE_REPO,
              owner: org,
              name,
              private: isPrivate,
              include_all_branches: false
            });
            core.info(`Generated repo: ${repo.full_name}`);

            const topics = (process.env.TOPICS || '')
              .split(',')
              .map(t => t.trim())
              .filter(Boolean);
            // Always ensure trunk-based-development topic is present.
            const forced = 'trunk-based-development';
            if (!topics.includes(forced)) topics.push(forced);
            await github.request('PUT /repos/{owner}/{repo}/topics', { owner: org, repo: name, names: topics });
            core.info(`Applied topics: ${topics.join(', ')}`);

            // Apply repository settings in safe phases to avoid 422 org policy violations.
            async function safePatch(body, label) {
              try {
                await github.request('PATCH /repos/{owner}/{repo}', { owner: org, repo: name, ...body });
                core.info(`Applied settings phase: ${label}`);
              } catch (e) {
                if (e.status === 422) {
                  core.warning(`Phase '${label}' skipped (422): ${e.message}`);
                } else {
                  core.warning(`Phase '${label}' error (${e.status||'?'}) => ${e.message}`);
                }
              }
            }

            // Phase 1: merge + collaboration basics (omit allow_forking to bypass org fork policy noise)
            await safePatch({
              allow_auto_merge: true,
              allow_merge_commit: false,
              allow_rebase_merge: true,
              allow_squash_merge: true,
              allow_update_branch: true,
              delete_branch_on_merge: false,
              has_issues: true,
              has_projects: false,
              has_wiki: false,
              is_template: false,
              squash_merge_commit_title: 'COMMIT_OR_PR_TITLE',
              squash_merge_commit_message: 'COMMIT_MESSAGES',
              allow_forking: false,
              web_commit_signoff_required: false
            }, 'merge-options');

            // Phase 2: security hardening (only attempt features likely available; guard each)
            await safePatch({
              security_and_analysis: {
                advanced_security: { status: 'enabled' },
                code_security: { status: 'enabled' },
                secret_scanning: { status: 'enabled' },
                secret_scanning_push_protection: { status: 'enabled' }
              }
            }, 'security-core');

            // Phase 3: optional extra scanners (may not be enabled for plan)
            await safePatch({
              security_and_analysis: {
                secret_scanning_ai_detection: { status: 'enabled' },
                secret_scanning_non_provider_patterns: { status: 'enabled' }
              }
            }, 'security-extended');

            core.info(`Configured repository settings for ${org}/${name}.`);

      - name: Wait for initial default branch
        id: wait-default-branch
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const start = Date.now();
            const timeoutMs = 180_000;
            let sleepMs = 2_000;
            const maxSleepMs = 10_000;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            async function ready() {
              const { data: repoData } = await github.request('GET /repos/{owner}/{repo}', { owner, repo });
              const branch = repoData.default_branch || 'main';
              try {
                const { data: b } = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
                if (b?.commit?.sha) return { branch, sha: b.commit.sha };
              } catch {}
              try {
                const { data: c } = await github.request('GET /repos/{owner}/{repo}/commits/{ref}', { owner, repo, ref: branch });
                if (c?.sha) return { branch, sha: c.sha };
              } catch {}
              return null;
            }

            while (Date.now() - start < timeoutMs) {
              const info = await ready();
              if (info) {
                core.setOutput('initial_branch', info.branch);
                core.setOutput('initial_sha', info.sha);
                core.exportVariable('INITIAL_BRANCH', info.branch);
                core.exportVariable('INITIAL_SHA', info.sha);
                return;
              }
              await sleep(sleepMs);
              sleepMs = Math.min(maxSleepMs, Math.floor(sleepMs * 1.6));
            }
            core.setFailed('Timed out waiting for the new repo default branch and first commit.');

      - name: Disable Copilot Agent Firewall
        continue-on-error: true
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const org = process.env.ORG;
            const repo = process.env.NEW_REPO;

            async function ensureVarDisabled() {
              try {
                // Try update (PATCH) first â€“ works only if variable already exists.
                await github.request('PATCH /repos/{owner}/{repo}/actions/variables/{name}', {
                  owner: org,
                  repo,
                  name: 'COPILOT_AGENT_FIREWALL_ENABLED',
                  value: 'false'
                });
                core.info('Updated existing variable COPILOT_AGENT_FIREWALL_ENABLED -> false');
                return;
              } catch (e) {
                if (e.status === 404) {
                  core.info('Variable does not exist yet; creating it.');
                  try {
                    await github.request('POST /repos/{owner}/{repo}/actions/variables', {
                      owner: org,
                      repo,
                      name: 'COPILOT_AGENT_FIREWALL_ENABLED',
                      value: 'false'
                    });
                    core.info('Created variable COPILOT_AGENT_FIREWALL_ENABLED=false');
                    return;
                  } catch (inner) {
                    if (inner.status === 403) {
                      core.warning('403 creating variable: GitHub App lacks Actions Variables write permission.');
                      return;
                    }
                    core.warning(`Failed to create variable (${inner.status||'?'}): ${inner.message}`);
                    return;
                  }
                }
                if (e.status === 403) {
                  core.warning('403 updating variable: GitHub App is missing the "Actions: Read and write" (variables) permission or feature not enabled. Skipping.');
                  return;
                }
                core.warning(`Failed to update variable (${e.status||'?'}): ${e.message}`);
              }
            }

            await ensureVarDisabled();
            core.info('Best-effort Copilot Agent Firewall disable step complete.');

      - name: Return pertinent information
        if: >
          ${{ always() }}
        uses: actions/github-script@v8
        with:
          script: |
            const repoUrl = `https://github.com/${process.env.ORG}/${process.env.NEW_REPO}`;

            core.summary
              .addHeading('Repository Overview', 2)
              .addEOL()
              .addRaw(`Repository Name: ${process.env.NEW_REPO}`)
              .addEOL()
              .addRaw(`Repository Owner: ${process.env.ORG}`)
              .addEOL()
              .addRaw(`Repository URL: ${repoUrl}`)
              .addSeparator();

            await core.summary.write();

            core.setOutput('repository_url', repoUrl);
            core.info(`Repository URL: ${repoUrl}`);
