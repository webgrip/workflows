name: "[Call] Bootstrap repository"

on:
  workflow_call:
    inputs:
      repo_name:
        description: "Name of the new repository"
        type: string
        required: true
      delete_files:
        description: "Comma-separated list of files/paths to delete from the new repository"
        type: string
        required: false
        default: ""
      replace_values:
        description: "YAML mapping of find->replace values (also used as oldPath->newPath for renames)"
        type: string
        required: false
        default: ""
    secrets:
      WEBGRIP_CI_CLIENT_ID:
        description: "GitHub App ID (numeric)"
        required: true
      WEBGRIP_CI_APP_PRIVATE_KEY:
        description: "GitHub App private key (PEM)"
        required: true
      OPENAI_API_KEY:
        description: "OpenAI API key"
        required: true
      OPENAI_ORG_ID:
        description: "OpenAI Organization ID"
        required: true

permissions:
  contents: write
  pull-requests: write
  actions: write
  pages: write

concurrency:
  group: bootstrap-${{ github.repository_id }}-${{ inputs.repo_name }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  bootstrap-repo:
    name: bootstrap
    runs-on: arc-runner-set

    env:
      ORG: ${{ github.repository_owner }}
      NEW_REPO: ${{ inputs.repo_name }}
      APP_BOT_SLUG: ${{ vars.WEBGRIP_CI_BOT_NAME }}

    steps:
      - name: Mint GitHub App installation token (owner-based)
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.WEBGRIP_CI_CLIENT_ID }}
          private-key: ${{ secrets.WEBGRIP_CI_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG }}

      - name: Check out new repo (development)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORG }}/${{ env.NEW_REPO }}
          ref: development
          fetch-depth: 0
          persist-credentials: false
          token: ${{ steps.app-token.outputs.token }}

      - name: Delete files (if provided)
        if: ${{ inputs.delete_files != '' }}
        run: |
          set -euo pipefail
          input="${{ inputs.delete_files }}"
          input="${input//$'\n'/,}"
          IFS=',' read -ra files <<< "$input"
          for file in "${files[@]}"; do
            f="$(echo "$file" | xargs)"   # trim
            [[ -z "$f" ]] && continue
            echo "Deleting: $f"
            rm -rf -- "$f"
          done

      - name: Replace values across repository (if provided)
        if: ${{ inputs.replace_values != '' }}
        uses: actions/github-script@v7
        env:
          REPLACE_VALUES_YAML: ${{ inputs.replace_values }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const root = process.env.GITHUB_WORKSPACE || process.cwd();
            const yamlRaw = (process.env.REPLACE_VALUES_YAML || '').trim();

            function parseSimpleYamlMap(yaml) {
              const map = {};
              for (const rawLine of yaml.split(/\r?\n/)) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) continue;
                const idx = line.indexOf(':');
                if (idx < 0) continue;
                let key = line.slice(0, idx).trim();
                let val = line.slice(idx + 1).trim();
                const unquote = (s) =>
                  (s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))
                    ? s.slice(1, -1)
                    : s;
                key = unquote(key);
                val = unquote(val);
                map[key] = val;
              }
              return map;
            }

            const replacements = parseSimpleYamlMap(yamlRaw);

            function walk(dir) {
              let out = [];
              let ents = [];
              try { ents = fs.readdirSync(dir, { withFileTypes: true }); } catch { return out; }
              for (const e of ents) {
                const full = path.join(dir, e.name);
                try { if (fs.lstatSync(full).isSymbolicLink()) continue; } catch {}
                if (e.name === '.git') continue;

                if (e.isDirectory()) out = out.concat(walk(full));
                else if (e.isFile()) out.push(full);
              }
              return out;
            }

            function replaceInFile(file) {
              if (file.includes(`${path.sep}.git${path.sep}`) || file.endsWith(`${path.sep}.git`)) return;

              // best-effort small guard: ignore huge files (>5MB)
              try {
                const { size } = fs.statSync(file);
                if (size > 5 * 1024 * 1024) return;
              } catch {}

              let content;
              try { content = fs.readFileSync(file, 'utf8'); }
              catch { return; } // binary/permission issues — skip

              for (const [search, replace] of Object.entries(replacements)) {
                if (!search) continue;
                content = content.split(search).join(String(replace));
              }

              try { fs.writeFileSync(file, content, 'utf8'); }
              catch { /* readonly or perms — skip */ }
            }

            const files = walk(root);
            for (const file of files) replaceInFile(file);

      - name: Rename / merge paths based on replace_values keys (if provided)
        if: ${{ inputs.replace_values != '' }}
        uses: actions/github-script@v7
        env:
          REPLACE_VALUES_YAML: ${{ inputs.replace_values }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const root = process.env.GITHUB_WORKSPACE || process.cwd();
            const yamlRaw = (process.env.REPLACE_VALUES_YAML || '').trim();

            function parseSimpleYamlMap(yaml) {
              const map = {};
              for (const rawLine of yaml.split(/\r?\n/)) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) continue;
                const idx = line.indexOf(':');
                if (idx < 0) continue;
                let key = line.slice(0, idx).trim();
                let val = line.slice(idx + 1).trim();
                const unquote = (s) =>
                  (s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))
                    ? s.slice(1, -1)
                    : s;
                key = unquote(key);
                val = unquote(val);
                map[key] = val;
              }
              return map;
            }

            const replacements = parseSimpleYamlMap(yamlRaw);
            const looksLikePath = (s) => typeof s === 'string' && (s.includes('/') || s.startsWith('.') || s.startsWith('_'));
            const isGitPath = (p) => p === '.git' || p.startsWith('.git/');

            function movePath(src, dest) {
              if (!src || !dest || src === dest) return;
              // never touch .git
              const relSrc = path.relative(root, src).replace(/\\/g, '/');
              const relDst = path.relative(root, dest).replace(/\\/g, '/');
              if (isGitPath(relSrc) || isGitPath(relDst)) return;

              if (!fs.existsSync(src)) return;

              const destDir = path.dirname(dest);
              fs.mkdirSync(destDir, { recursive: true });

              if (fs.existsSync(dest)) {
                const statSrc = fs.statSync(src);
                const statDst = fs.statSync(dest);
                if (statSrc.isDirectory() && statDst.isDirectory()) {
                  for (const entry of fs.readdirSync(src)) {
                    movePath(path.join(src, entry), path.join(dest, entry));
                  }
                  fs.rmSync(src, { recursive: true, force: true });
                  return;
                } else {
                  fs.rmSync(dest, { recursive: true, force: true });
                }
              }
              fs.renameSync(src, dest);
            }

            for (const [search, replace] of Object.entries(replacements)) {
              if (!looksLikePath(search) || !looksLikePath(replace)) continue;
              const src = path.join(root, search);
              const dst = path.join(root, replace);
              movePath(src, dst);
            }

      - name: Resolve bot noreply email
        id: bot-email
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const slug = process.env.APP_BOT_SLUG || 'webgrip-ci';
            const username = `${slug}[bot]`;
            try {
              const { data: user } = await github.request('GET /users/{username}', { username });
              core.setOutput('name', username);
              core.setOutput('email', `${user.id}+${username}@users.noreply.github.com`);
            } catch {
              core.setOutput('name', 'github-actions[bot]');
              core.setOutput('email', '41898282+github-actions[bot]@users.noreply.github.com');
            }

      - name: Authenticate git remote for push
        env:
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${APP_TOKEN}@github.com/${ORG}/${NEW_REPO}.git"

      - name: Commit and push changes to development (if any)
        run: |
          set -euo pipefail
          git config user.name  "${{ steps.bot-email.outputs.name }}"
          git config user.email "${{ steps.bot-email.outputs.email }}"
          git add -A
          if git diff --cached --quiet; then
            echo "Nothing to commit."
          else
            git commit -m "chore(init): personalize ${NEW_REPO}"
            git push origin HEAD:development
          fi

      - name: Open PR from development to main (idempotent)
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;

            const { data: prs } = await github.request('GET /repos/{owner}/{repo}/pulls', {
              owner, repo, state: 'open', base: 'main', head: `${owner}:development`
            });
            if (Array.isArray(prs) && prs.length > 0) {
              core.info(`PR already open: #${prs[0].number} ${prs[0].html_url}`);
              return;
            }

            const title = "chore(init): personalize repository";
            const body  = "Automated initialization PR from `development` to `main`.";
            const { data: pr } = await github.request('POST /repos/{owner}/{repo}/pulls', {
              owner, repo, title, body, base: 'main', head: 'development', maintainer_can_modify: true, draft: false
            });
            core.info(`PR opened: #${pr.number} ${pr.html_url}`);

      - name: Create OpenAI Project (best-effort)
        id: openai-project
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_ORG_ID: ${{ secrets.OPENAI_ORG_ID }}
        with:
          script: |
            const apiKey = process.env.OPENAI_API_KEY;
            const orgId  = process.env.OPENAI_ORG_ID || '';
            const repo   = process.env.NEW_REPO;
            const owner  = process.env.ORG;

            const headers = {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json',
              ...(orgId ? { 'OpenAI-Organization': orgId } : {})
            };

            try {
              const createRes = await fetch('https://api.openai.com/v1/projects', {
                method: 'POST', headers,
                body: JSON.stringify({ name: repo, description: `Auto-created for ${owner}/${repo}` })
              });
              const txt = await createRes.text();
              if (!createRes.ok) { core.warning(`OpenAI project create failed (${createRes.status}): ${txt}`); return; }
              let data = {}; try { data = JSON.parse(txt); } catch {}
              const projectId = data.id || data.project_id || '';
              if (!projectId) { core.warning('OpenAI project created but no id returned.'); return; }
              core.setOutput('project_id', projectId);
              core.info(`OpenAI project id: ${projectId}`);

              try {
                const linkRes = await fetch(`https://api.openai.com/v1/projects/${projectId}`, {
                  method: 'PATCH', headers,
                  body: JSON.stringify({ metadata: { github_repo: `${owner}/${repo}`, github_url: `https://github.com/${owner}/${repo}` } })
                });
                if (!linkRes.ok) core.warning(`OpenAI project link warning (${linkRes.status})`);
              } catch (e) {
                core.warning(`OpenAI project link error: ${e.message}`);
              }
            } catch (e) {
              core.warning(`OpenAI project create error: ${e.message}`);
            }

      - name: Store OPENAI_PROJECT_ID as repo variable (best-effort)
        if: ${{ steps.openai-project.outputs.project_id != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const varName = 'OPENAI_PROJECT_ID';
            const value   = `${{ steps.openai-project.outputs.project_id }}`;
            try {
              await github.request('POST /repos/{owner}/{repo}/actions/variables', { owner, repo, name: varName, value });
              core.info(`Created repo variable ${varName}.`);
            } catch (e) {
              if (e.status === 422) {
                await github.request('PATCH /repos/{owner}/{repo}/actions/variables/{name}', { owner, repo, name: varName, value });
                core.info(`Updated repo variable ${varName}.`);
              } else {
                core.warning(`Could not set repo variable ${varName}: ${e.status}`);
              }
            }

      - name: Ensure gh-pages branch, configure Pages, and set homepage (best-effort)
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;

            async function branchExists(branch) {
              try {
                await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
                return true;
              } catch (e) {
                if (e.status === 404) return false;
                throw e;
              }
            }

            async function getCommitSha(branch) {
              const { data } = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
              return data.commit.sha;
            }

            async function baseSha() {
              if (await branchExists('development')) return getCommitSha('development');
              return getCommitSha('main');
            }

            if (!(await branchExists('gh-pages'))) {
              try {
                const sha = await baseSha();
                await github.request('POST /repos/{owner}/{repo}/git/refs', { owner, repo, ref: 'refs/heads/gh-pages', sha });
                core.info('Created gh-pages branch.');
              } catch (e) {
                core.warning(`Failed to create gh-pages branch: ${e.status || ''} ${e.message}`);
                return;
              }
            } else {
              core.info('gh-pages branch already exists.');
            }

            async function getPages() {
              try {
                const { data } = await github.request('GET /repos/{owner}/{repo}/pages', { owner, repo });
                return data;
              } catch (e) {
                if (e.status === 404) return null;
                throw e;
              }
            }

            const source = { branch: 'gh-pages', path: '/' };
            const existing = await getPages();

            try {
              if (existing) {
                await github.request('PUT /repos/{owner}/{repo}/pages', { owner, repo, source });
                core.info('Updated GitHub Pages to deploy from gh-pages /.');
              } else {
                await github.request('POST /repos/{owner}/{repo}/pages', { owner, repo, source });
                core.info('Enabled GitHub Pages to deploy from gh-pages /.');
              }
            } catch (e) {
              if (e.status === 403) {
                core.warning('Pages API returned 403. Ensure the GitHub App has "Pages: Read and write" and Pages are allowed for the org.');
              } else {
                core.warning(`Pages configuration error: ${e.status || ''} ${e.message}`);
              }
            }

            let pagesUrl = `https://${owner}.github.io/${repo}/`;
            try {
              const info = await getPages();
              if (info?.html_url) pagesUrl = info.html_url;
            } catch {}
            try {
              await github.request('PATCH /repos/{owner}/{repo}', { owner, repo, homepage: pagesUrl });
              core.info(`Set repository homepage to ${pagesUrl}`);
            } catch (e) {
              core.warning(`Could not set repository homepage: ${e.status || ''} ${e.message}`);
            }
