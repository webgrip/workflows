name: "[Call] Bootstrap repository"

on:
  workflow_call:
    inputs:
      repo_name:
        description: "Name of the new repository"
        type: string
        required: true
      delete_files:
        description: "Comma-separated list of files/paths to delete"
        type: string
        required: false
        default: ""
      replace_values:
        description: "YAML mapping of find->replace (also used as oldPath->newPath for renames)"
        type: string
        required: false
        default: ""
      force_commit_files:
        description: "Comma-separated list of files/paths to force commit"
        type: string
        required: false
        default: ""
      configure_pages:
        description: "Configure gh-pages branch and GitHub Pages"
        type: boolean
        required: false
        default: false
    outputs:
      repository_url:
        description: "URL of the newly bootstrapped repository"
        value: ${{ jobs.bootstrap-repo.outputs.repository_url }}
    secrets:
      WEBGRIP_CI_CLIENT_ID:
        description: "GitHub App ID (numeric)"
        required: true
      WEBGRIP_CI_APP_PRIVATE_KEY:
        description: "GitHub App private key (PEM)"
        required: true
      OPENAI_API_KEY:
        description: "OpenAI API key"
        required: false
      OPENAI_ORG_ID:
        description: "OpenAI Organization ID"
        required: false

permissions:
  contents: write
  pull-requests: write
  actions: write
  pages: write
  issues: write

concurrency:
  group: bootstrap-${{ github.repository_id }}-${{ inputs.repo_name }}
  cancel-in-progress: false

defaults:
  run:
    shell: bash

jobs:
  bootstrap-repo:
    name: "Bootstrap repository"
    runs-on: arc-runner-set
    outputs:
      repository_url: ${{ steps.compute-urls.outputs.repository_url }}

    env:
      ORG: ${{ github.repository_owner }}
      NEW_REPO: ${{ inputs.repo_name }}
      APP_BOT_SLUG: ${{ vars.WEBGRIP_CI_BOT_NAME }}

    steps:
      - name: Mint GitHub App installation token (owner-based)
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.WEBGRIP_CI_CLIENT_ID }}
          private-key: ${{ secrets.WEBGRIP_CI_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG }}

      - name: Check out new repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.ORG }}/${{ env.NEW_REPO }}
          ref: main
          fetch-depth: 0
          persist-credentials: false
          token: ${{ steps.app-token.outputs.token }}

      - name: Delete files (if provided)
        if: ${{ inputs.delete_files != '' }}
        run: |
          set -euo pipefail
          input="${{ inputs.delete_files }}"
          input="${input//$'\n'/,}"
          IFS=',' read -ra files <<< "$input"
          for file in "${files[@]}"; do
            f="$(echo "$file" | xargs)"
            [[ -z "$f" ]] && continue
            # Block workflow deletions (guard always active)
            if [[ "$f" == .github/workflows* ]]; then
              echo "Skipping deletion in .github/workflows (guard active): $f"
              continue
            fi
            echo "Deleting: $f"
            rm -rf -- "$f"
          done

      - name: Replace values across repository (if provided)
        if: ${{ inputs.replace_values != '' }}
        uses: actions/github-script@v8
        env:
          REPLACE_VALUES_YAML: ${{ inputs.replace_values }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const root = process.env.GITHUB_WORKSPACE || process.cwd();
            const yamlRaw = (process.env.REPLACE_VALUES_YAML || '').trim();
            const allowWF = false;
            function parseSimpleYamlMap(yaml) {
              const map = {};
              for (const rawLine of yaml.split(/\r?\n/)) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) continue;
                const idx = line.indexOf(':');
                if (idx < 0) continue;
                let key = line.slice(0, idx).trim();
                let val = line.slice(idx + 1).trim();
                const unquote = (s) =>
                  (s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))
                    ? s.slice(1, -1)
                    : s;
                key = unquote(key);
                val = unquote(val);
                map[key] = val;
              }
              return map;
            }

            const replacements = parseSimpleYamlMap(yamlRaw);
            const shouldSkip = (p) => {
              const rel = path.relative(root, p).replace(/\\/g, '/');
              if (rel === '.git' || rel.startsWith('.git/')) return true;
              if (!allowWF && (rel === '.github/workflows' || rel.startsWith('.github/workflows/'))) return true;
              return false;
            };

            function walk(dir) {
              if (shouldSkip(dir)) return [];
              let out = [];
              let ents = [];
              try { ents = fs.readdirSync(dir, { withFileTypes: true }); } catch { return out; }
              for (const e of ents) {
                const full = path.join(dir, e.name);
                try { if (fs.lstatSync(full).isSymbolicLink()) continue; } catch {}
                if (shouldSkip(full)) continue;
                if (e.isDirectory()) out = out.concat(walk(full));
                else if (e.isFile()) out.push(full);
              }
              return out;
            }

            function replaceInFile(file) {
              // tiny guard: skip large files
              try {
                const { size } = fs.statSync(file);
                if (size > 5 * 1024 * 1024) return;
              } catch {}
              let content;
              try { content = fs.readFileSync(file, 'utf8'); } catch { return; }
              for (const [search, replace] of Object.entries(replacements)) {
                if (!search) continue;
                content = content.split(search).join(String(replace));
              }
              try { fs.writeFileSync(file, content, 'utf8'); } catch {}
            }

            const files = walk(root);
            for (const file of files) replaceInFile(file);

      - name: Rename / merge paths based on replace_values keys (if provided)
        if: ${{ inputs.replace_values != '' }}
        uses: actions/github-script@v8
        env:
          REPLACE_VALUES_YAML: ${{ inputs.replace_values }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const root = process.env.GITHUB_WORKSPACE || process.cwd();
            const yamlRaw = (process.env.REPLACE_VALUES_YAML || '').trim();
            const allowWF = false;

            function parseSimpleYamlMap(yaml) {
              const map = {};
              for (const rawLine of yaml.split(/\r?\n/)) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) continue;
                const idx = line.indexOf(':');
                if (idx < 0) continue;
                let key = line.slice(0, idx).trim();
                let val = line.slice(idx + 1).trim();
                const unquote = (s) =>
                  (s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))
                    ? s.slice(1, -1)
                    : s;
                key = unquote(key);
                val = unquote(val);
                map[key] = val;
              }
              return map;
            }

            const replacements = parseSimpleYamlMap(yamlRaw);
            const looksLikePath = (s) => typeof s === 'string' && (s.includes('/') || s.startsWith('.') || s.startsWith('_'));
            const isBlocked = (rel) => {
              if (rel === '.git' || rel.startsWith('.git/')) return true;
              if (!allowWF && (rel === '.github/workflows' || rel.startsWith('.github/workflows/'))) return true;
              return false;
            };

            function movePath(src, dest) {
              const relSrc = path.relative(root, src).replace(/\\/g, '/');
              const relDst = path.relative(root, dest).replace(/\\/g, '/');
              if (isBlocked(relSrc) || isBlocked(relDst)) return;
              if (!fs.existsSync(src)) return;

              const destDir = path.dirname(dest);
              fs.mkdirSync(destDir, { recursive: true });

              if (fs.existsSync(dest)) {
                const statSrc = fs.statSync(src);
                const statDst = fs.statSync(dest);
                if (statSrc.isDirectory() && statDst.isDirectory()) {
                  for (const entry of fs.readdirSync(src)) {
                    movePath(path.join(src, entry), path.join(dest, entry));
                  }
                  fs.rmSync(src, { recursive: true, force: true });
                  return;
                } else {
                  fs.rmSync(dest, { recursive: true, force: true });
                }
              }
              fs.renameSync(src, dest);
            }

            for (const [search, replace] of Object.entries(replacements)) {
              if (!looksLikePath(search) || !looksLikePath(replace)) continue;
              const src = path.join(root, search);
              const dst = path.join(root, replace);
              if (src === dst) continue;
              movePath(src, dst);
            }

      - name: Resolve bot noreply email
        id: bot-email
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const slug = process.env.APP_BOT_SLUG || 'webgrip-ci';
            const username = `${slug}[bot]`;
            try {
              const { data: user } = await github.request('GET /users/{username}', { username });
              core.setOutput('name', username);
              core.setOutput('email', `${user.id}+${username}@users.noreply.github.com`);
            } catch {
              core.setOutput('name', 'github-actions[bot]');
              core.setOutput('email', '41898282+github-actions[bot]@users.noreply.github.com');
            }

      - name: Authenticate git remote for push
        env:
          APP_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${APP_TOKEN}@github.com/${ORG}/${NEW_REPO}.git"

      - name: Commit and push changes to main (if any)
        run: |
          set -euo pipefail
          git config user.name  "${{ steps.bot-email.outputs.name }}"
          git config user.email "${{ steps.bot-email.outputs.email }}"
          git add -A

          # If no staged changes yet, optionally force-create or touch files listed in force_commit_files
          if git diff --cached --quiet; then
            fc_list="${{ inputs.force_commit_files }}"
            if [[ -n "${fc_list// }" ]]; then
              IFS=',' read -ra fc_files <<< "$fc_list"
              for file in "${fc_files[@]}"; do
                f="$(echo "$file" | xargs)"
                [[ -z "$f" ]] && continue
                # Respect workflow guard: do not modify workflow files
                if [[ "$f" == .github/workflows* ]]; then
                  echo "Skipping force touch in .github/workflows (guard active): $f"
                  continue
                fi
                if [[ -e "$f" ]]; then
                  echo "# force touch $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$f" || true
                else
                  mkdir -p "$(dirname "$f")"
                  echo "# bootstrap force placeholder $(date -u +%Y-%m-%dT%H:%M:%SZ)" > "$f" || true
                fi
              done
              git add -A
            fi
          fi

          if git diff --cached --quiet; then
            echo "Nothing to commit."
          else
            git commit -m "chore(init): personalize ${NEW_REPO}"
            git push origin HEAD:main
          fi

      - name: Compute repository URL output
        id: compute-urls
        run: |
          set -euo pipefail
          echo "repository_url=https://github.com/${ORG}/${NEW_REPO}" >> "$GITHUB_OUTPUT"

      - name: Ensure gh-pages branch, configure Pages, and set homepage (best-effort, opt-in)
        if: ${{ inputs.configure_pages }}
        continue-on-error: true
        uses: actions/github-script@v8
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;

            async function branchExists(branch) {
              try {
                await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
                return true;
              } catch (e) { if (e.status === 404) return false; throw e; }
            }
            async function getSha(branch) {
              const { data } = await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch });
              return data.commit.sha;
            }
            const baseSha = await getSha('main');

            try {
              await github.request('GET /repos/{owner}/{repo}/branches/{branch}', { owner, repo, branch: 'gh-pages' });
              core.info('gh-pages branch already exists.');
            } catch (e) {
              if (e.status === 404) {
                await github.request('POST /repos/{owner}/{repo}/git/refs', { owner, repo, ref: 'refs/heads/gh-pages', sha: baseSha });
                core.info('Created gh-pages branch.');
              } else { core.warning(`Failed to check/create gh-pages: ${e.status||''} ${e.message}`); return; }
            }

            async function getPages() {
              try {
                const { data } = await github.request('GET /repos/{owner}/{repo}/pages', { owner, repo });
                return data;
              } catch (e) { if (e.status === 404) return null; throw e; }
            }

            const source = { branch: 'gh-pages', path: '/' };
            const existing = await getPages();
            try {
              if (existing) { await github.request('PUT /repos/{owner}/{repo}/pages', { owner, repo, source }); }
              else { await github.request('POST /repos/{owner}/{repo}/pages', { owner, repo, source }); }
              core.info('Configured GitHub Pages to deploy from gh-pages /.');
            } catch (e) {
              if (e.status === 403) core.warning('Pages API 403. Ensure app has "Pages: Read and write" and org allows Pages.');
              else core.warning(`Pages configuration error: ${e.status||''} ${e.message}`);
            }

            let pagesUrl = `https://${owner}.github.io/${repo}/`;
            try { const info = await getPages(); if (info?.html_url) pagesUrl = info.html_url; } catch {}
            try { await github.request('PATCH /repos/{owner}/{repo}', { owner, repo, homepage: pagesUrl }); } catch {}
            core.info(`Set repository homepage to ${pagesUrl}`);

