name: "[Call] Bootstrap repository issues"

on:
  workflow_call:
    inputs:
      repo_name:
        description: "Name of the new repository"
        type: string
        required: true
    secrets:
      WEBGRIP_CI_CLIENT_ID:
        description: "GitHub App ID (numeric)"
        required: true
      WEBGRIP_CI_APP_PRIVATE_KEY:
        description: "GitHub App private key (PEM)"
        required: true
permissions:
  issues: write
  contents: write
jobs:
  bootstrap-issues:
    name: "Bootstrap repository issues"
    runs-on: arc-runner-set
    env:
      ORG: ${{ github.repository_owner }}
      NEW_REPO: ${{ inputs.repo_name }}
    steps:
      - name: Mint GitHub App installation token (owner-based)
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.WEBGRIP_CI_CLIENT_ID }}
          private-key: ${{ secrets.WEBGRIP_CI_APP_PRIVATE_KEY }}
          owner: ${{ env.ORG }}
      - name: Fetch issue templates repository
        uses: actions/checkout@v4
        with:
          repository: webgrip/issue-templates
          path: __issue_templates
          fetch-depth: 1
          persist-credentials: false
          token: ${{ steps.app-token.outputs.token }}
      - name: Create project setup issue chain
        id: create-issues
        uses: actions/github-script@v7
        env:
          PROJECT_NAME: ${{ env.NEW_REPO }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = process.env.ORG;
            const repo  = process.env.NEW_REPO;
            const projectName = process.env.PROJECT_NAME;
            const fs = require('fs');
            const path = require('path');
            const root = path.join(process.env.GITHUB_WORKSPACE || process.cwd(), '__issue_templates');
            const MARKER_PREFIX = '<!-- managed:bootstrap-issue:';
            const MARKER_SUFFIX = ' -->';
            const ISSUE_SPECS = [
              { slug: 'main',   defaultTitle: (n) => `Set up project ${n}`, templateHints: ['0010-setup-project/0010-documentation.md'] },
              { slug: 'docs',   defaultTitle: () => 'Set up documentation', templateHints: ['0010-setup-project/0010-documentation.md'] },
              { slug: 'docker', defaultTitle: () => 'Set up Docker environment', templateHints: ['0020-docker.md'] },
              { slug: 'helm',   defaultTitle: () => 'Set up Helm chart', templateHints: ['0030-helm.md'] },
            ];
            async function listIssues(state = 'all', perPage = 50, maxPages = 4) {
              const out = [];
              for (let page = 1; page <= maxPages; page++) {
                const { data } = await github.request('GET /repos/{owner}/{repo}/issues', { owner, repo, state, per_page: perPage, page });
                if (!data.length) break;
                out.push(...data.filter(i => !i.pull_request));
              }
              return out;
            }
            function extractFrontMatter(raw) {
              if (!raw.startsWith('---')) return { front: {}, body: raw };
              const end = raw.indexOf('\n---', 3);
              if (end === -1) return { front: {}, body: raw };
              const meta = raw.slice(3, end).trim();
              const rest = raw.slice(end + 4).replace(/^\s*\n/, '');
              const front = {};
              let currentKey = null;
              meta.split(/\r?\n/).forEach(line => {
                if (/^\s*-\s+/.test(line) && currentKey) {
                  const val = line.replace(/^\s*-\s+/, '').trim();
                  if (!Array.isArray(front[currentKey])) front[currentKey] = [];
                  front[currentKey].push(val.replace(/^"|"$/g,'').replace(/^'|'$/g,''));
                  return;
                }
                const m = line.match(/^([A-Za-z0-9_-]+):\s*(.*)$/);
                if (m) {
                  currentKey = m[1];
                  let v = m[2].trim();
                  if (v === '') { front[currentKey] = []; }
                  else front[currentKey] = v.replace(/^"|"$/g,'').replace(/^'|'$/g,'');
                }
              });
              return { front, body: rest };
            }
            function loadTemplate(hints) {
              for (const base of hints) {
                const variants = [base, `${base}.md`, `${base}.MD`, base.toLowerCase(), `${base.toLowerCase()}.md`];
                for (const v of variants) {
                  const full = path.join(root, v);
                  if (fs.existsSync(full) && fs.statSync(full).isFile()) {
                    try { return fs.readFileSync(full, 'utf8'); } catch {}
                  }
                }
              }
              return null;
            }
            async function ensureLabel(name, color = '0E8A16', description = '') {
              const norm = name.trim();
              try {
                await github.request('GET /repos/{owner}/{repo}/labels/{name}', { owner, repo, name: norm });
                return;
              } catch(e) {
                if (e.status !== 404) return;
              }
              try {
                await github.request('POST /repos/{owner}/{repo}/labels', { owner, repo, name: norm, color, description });
              } catch(e) { /* ignore */ }
            }
            function buildManagedBody(slug, content, blockingNumbers = []) {
              const marker = `${MARKER_PREFIX}${slug}${MARKER_SUFFIX}`;
              const blockLine = blockingNumbers.length ? `\n\nBlocked by ${blockingNumbers.map(n => '#' + n).join(' ')}` : '';
              if (content.includes(marker)) return content;
              return `${marker}\n\n${content.trim()}${blockLine}`.trim() + '\n';
            }
            function bodyNeedsUpdate(current, desired) {
              const norm = s => s.replace(/\s+$/gm,'').trim();
              return norm(current || '') !== norm(desired || '');
            }
            const existingIssues = await listIssues('all');
            const bySlug = {};
            for (const iss of existingIssues) {
              const m = iss.body && iss.body.match(/<!-- managed:bootstrap-issue:([a-z0-9-]+) -->/);
              if (m) bySlug[m[1]] = iss;
            }
            const created = {};
            for (const spec of ISSUE_SPECS) {
              const raw = loadTemplate(spec.templateHints) || '';
              const { front, body } = extractFrontMatter(raw);
              const title = front.title ? front.title.replace(/<project name>/gi, projectName) : spec.defaultTitle(projectName);
              const tags = Array.isArray(front.tags) ? front.tags : [];
              const baseBody = body ? body : `Placeholder content for ${title} (template not found).`;
              const existing = bySlug[spec.slug];
              const managedBody = buildManagedBody(spec.slug, baseBody, []);
              for (const t of tags) await ensureLabel(t);
              if (!existing) {
                const { data: newIssue } = await github.request('POST /repos/{owner}/{repo}/issues', {
                  owner, repo, title, body: managedBody, labels: tags
                });
                bySlug[spec.slug] = newIssue;
                created[spec.slug] = newIssue;
              } else {
                let need = false;
                const patch = { owner, repo, issue_number: existing.number };
                if (existing.title !== title) { patch.title = title; need = true; }
                if (bodyNeedsUpdate(existing.body, managedBody)) { patch.body = managedBody; need = true; }
                if (tags.length) {
                  const cur = (existing.labels || []).map(l => (typeof l === 'string' ? l : l.name));
                  const want = [...new Set(tags)];
                  if (cur.sort().join(',') !== want.sort().join(',')) { patch.labels = want; need = true; }
                }
                if (need) {
                  const { data: upd } = await github.request('PATCH /repos/{owner}/{repo}/issues/{issue_number}', patch);
                  bySlug[spec.slug] = upd;
                }
              }
            }
            function updateBlocking(slug, blockers) {
              const iss = bySlug[slug];
              if (!iss) return;
              const marker = `${MARKER_PREFIX}${slug}${MARKER_SUFFIX}`;
              const bodyWithoutBlock = (iss.body || '').replace(/\n\nBlocked by (#\d+(\s+#\d+)*)$/,'');
              const desired = buildManagedBody(slug, bodyWithoutBlock.replace(marker,'').trim(), blockers);
              if (bodyNeedsUpdate(iss.body, desired)) {
                return github.request('PATCH /repos/{owner}/{repo}/issues/{issue_number}', { owner, repo, issue_number: iss.number, body: desired });
              }
            }
            await updateBlocking('docs', []);
            await updateBlocking('docker', [bySlug.docs.number]);
            await updateBlocking('helm', [bySlug.docker.number]);
            await updateBlocking('main', [bySlug.docs.number, bySlug.docker.number, bySlug.helm.number]);
            const mainIssue = bySlug.main;
            if (mainIssue) {
              const ckLines = [
                `- [ ] #${bySlug.docs.number} Set up documentation`,
                `- [ ] #${bySlug.docker.number} Set up Docker environment`,
                `- [ ] #${bySlug.helm.number} Set up Helm chart`
              ];
              const CHECK_HEADER = '### Initial Setup Tasks';
              let body = mainIssue.body || '';
              if (!body.includes(CHECK_HEADER)) {
                body += `\n\n${CHECK_HEADER}\n${ckLines.join('\n')}`;
                await github.request('PATCH /repos/{owner}/{repo}/issues/{issue_number}', { owner, repo, issue_number: mainIssue.number, body });
              }
            }
            core.setOutput('main_issue', bySlug.main.number);
            core.setOutput('docs_issue', bySlug.docs.number);
            core.setOutput('docker_issue', bySlug.docker.number);
            core.setOutput('helm_issue', bySlug.helm.number);
            core.summary
              .addHeading('Setup issues (idempotent sync)', 2)
              .addRaw(`Main: #${bySlug.main.number}`) .addEOL()
              .addRaw(`Docs: #${bySlug.docs.number}`) .addEOL()
              .addRaw(`Docker: #${bySlug.docker.number}`) .addEOL()
              .addRaw(`Helm: #${bySlug.helm.number}`) .addEOL();
            await core.summary.write();
            core.info(`Issue chain: main #${bySlug.main.number} -> docs #${bySlug.docs.number} -> docker #${bySlug.docker.number} -> helm #${bySlug.helm.number}`);
